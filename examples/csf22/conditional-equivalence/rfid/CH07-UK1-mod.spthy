theory CH07_UK1_mod begin

/*
  This theory models LAK06 including the readers.
  Model is taken from the Tamarin source code repository:
  examples/features/xor/diff-models/LAK06-UK1.spthy
*/

builtins: xor, hashing, multiset
functions: rot/2, lh/1, rh/1

rule setup:
   let data1 = <~k1,~id1>
       data2 = <~k2,~id2>
       datab = diff(data1, data2)
   in
   [ Fr( ~k1 )
   , Fr( ~id1 )
   , Fr( ~k2 )
   , Fr( ~id2 )
   ]
--[ OnlyOnce() ]->
   [  !TagRun(data1, 'learning')
    , !ReaderRun(data1, 'learning')
    , !TagRun(data2, 'learning')
    , !ReaderRun(data2, 'learning')
    , !TagRun(datab, 'guessing')
   ]

rule reader1:
   [ Fr( ~r1 ) ]
 --[ Challenge( ~r1, 'Reader' ) ]->
   [ Out( ~r1 )
   , Initiated( ~r1 )
   ]


rule tag1_learn:
   let hash = h((r1⊕~r2⊕~k)) in
   [ In( r1 )
   , Fr( ~r2 )
   , !TagRun( <~k, ~id>, 'learning' )
   ]
 --[ Response( ~k, 'Tag' )
   , Challenge(~r2, 'Tag')
   , PhaseLearning()
   ]->
   [ Out( <~r2,lh(rot(~id,hash) XOR hash)>)
   , TagState(~k, ~id, r1, ~r2, hash, 'learning')
   ]

rule tag1_guess:
   let hash = h((r1⊕~r2⊕~k)) in
   [ In( r1 )
   , Fr( ~r2 )
   , !TagRun( <~k, ~id>, 'guessing' )
   ]
 --[ Response( ~k, 'Tag' )
   , Challenge(~r2, 'Tag')
   , PhaseGuessing()
   ]->
   [ Out( <~r2,lh(rot(~id,hash) XOR hash)>)
   , TagState(~k, ~id, r1, ~r2, hash, 'guessing')
   ]

rule reader2_learn:
let
   // note: we use pattern-matching instead of equality
   // for the hash, as opposed the the original model
   hash = h((~r1⊕r2⊕~k))
in
   [ Initiated( ~r1 )
   , !ReaderRun( <~k, ~id>, 'learning')
   , In( <r2, lh(rot(~id,hash) XOR hash)> )
   ]
 --[ Alive( ~k, 'Tag' )
   , Response(~k, 'Reader')
   // , Eq( h((~r1⊕r2⊕~k)), hash )
   , PhaseLearning()
   ]->
   [ Out( rh(rot(~id,hash) XOR hash) ) ]

rule reader2_guess:
let
   // note: we use pattern-matching instead of equality
   // for the hash, as opposed the the original model
   hash = h((~r1⊕r2⊕~k))
in
   [ Initiated( ~r1 )
   , !ReaderRun( <~k, ~id>, 'guessing')
   , In( <r2, lh(rot(~id,hash) XOR hash)> )
   ]
 --[ Alive( ~k, 'Tag' )
   , Response(~k, 'Reader')
   // , Eq( h((~r1⊕r2⊕~k)), hash )
   , PhaseGuessing()
   ]->
   [ Out( rh(rot(~id,hash) XOR hash) ) ]

rule tag2_learn:
   [ In( rh(rot(~id,hash) XOR hash) )
   , TagState(~k, ~id, r1, ~r2, hash, 'learning')
   ]
 --[ Alive( ~k, 'Reader' ), PhaseLearning() ]->
   [ ]

rule tag2_guess:
   [ In( rh(rot(~id,hash) XOR hash) )
   , TagState(~k, ~id, r1, ~r2, hash, 'guessing')
   ]
 --[ Alive( ~k, 'Reader' ), PhaseGuessing() ]->
   [ ]

// restriction equality:
//   "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"

restriction unique:
  "∀ #i #j. ((OnlyOnce() @ #i) ∧ (OnlyOnce() @ #j)) ⇒ (#i = #j)"

restriction complyWithPhase:
  "All #i1 #i2. PhaseLearning()@i1 & PhaseGuessing()@i2 ==> #i1 < #i2"

lemma executable:
  exists-trace "∃ x #j. ((Response( x, 'Tag' ) @ #j))"

end
